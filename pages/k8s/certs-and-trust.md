---
wrapper_template: "base-docs.html"
markdown_includes:
  nav: "shared/_side-navigation.md"
context:
  title: "Certificates and Trust Management"
  description: How CDK manages PKI certificates and trust
keywords: juju, kubernetes, cdk, security, pki, encryption, vault, ha
tags: [operating, security]
sidebar: k8smain-sidebar
permalink: certs-and-trust.html
layout: [base, ubuntu-com]
toc: False
---

# Securing Communications with PKI

The components of [CDK][] need to be able to communicate securely over the
network.  This is accomplished using [TLS] and [public-key encryption][PKI]
with a [chain of trust][] up to a shared root [Certificate Authority (CA)][CA].
However, when the cluster is being brought up or a new unit is being added, the
chain of trust and certificates required must be bootstrapped into the machines
somehow.

## Juju Relations

All communication between [Juju units][] and the [Juju controller][] happens
over TLS-encrypted [websockets][].  The certificate for the TLS connection to
the controller is added as explicitly trusted to each machine as part of the
bootstrap process using a combination of [cloud-init][] and SSH.

With this secure channel, Juju charms can communicate with each other using
[relation][] data.  The data published by one unit is sent to the controller,
which then makes it available for all other units on the same relation.  The
data for each relation is scoped by ID and is only visible to units
participating in the specific relation on which it is set.  However, it is
worth noting that relation data is stored on the controller machine in MongoDB,
so for truly sensitive information, proper secret storage engines, such as
[Vault][vault-charm], and encryption-at-rest should be used.

## Managing Certificates

Unfortunately, the Juju controller does not provide any mechanisms for
generating or distributing additional certificates to be used by the
applications on the machines, so they must be managed by the charms via the
secure relation data channel.  This is done using the [tls-certificates][]
[interface protocol][interface] and a relation to an application providing a
Certificate Authority.  (This CA could be either a root CA, or an intermediary
CA authorized by some other root CA to issue certificates.)

When the relation is established, the root CA's certificate is sent via the
relation and [installed][install_ca_cert] as trusted.  Then, certificate
requests can be issued over the relation and new certificates created by the CA
and returned over the relation.

Because all units with a relation to the CA have a chain of trust up to it (or
its root CA), they will automatically trust a certificate generated by the CA
without requiring anything to be communicated from the unit which holds the
certificate.  On the other hand, for the certificates to be trusted externally
(such as by clients) or by applications without a relation to the CA, the CA
will have to be configured as an intermediary CA with a chain of trust up to a
globally trusted CA (such as [Comodo][] or [DigiCert][]).

The certificate information will also be included in the Kubernetes `config`
file that CDK generates to be used by [kubelet][], so that communications
between the local machine and Kubernetes will be secured.

## Server Certificates

Each service that will be connected to will need a [server certificate][]
identifying and validating it to any clients that wish to connect.

The primary address at which the service can be reached will be its [common
name][CN]; ideally, this will be a fully-qualified domain name (FQDN) which
will not change, but for internal service communication, it is often just the
[ingress address][network primitives] for the unit.  Any additional names or
addresses by which the service can be reached will be its [subject alternative
names (SANs)][SANs].

CDK will manage the server certificates automatically, including generating the
certificate with the proper CN and SANs.  However, the [kubernetes-master][]
charm also supports an [`extra_sans`][] option which can be used to provide
additional names to be added to the SANs list.

## Client Certificates

In order to provide for two-way security, some services require that clients
identify themselves via a [client certificate][].  These are more or less the
same as server certificates, but are presented by the client to the service
they are connecting to, so that the service can validate that the client is who
it claims to be.  Client certificates can **only** be used to identify a client
and will be rejected by clients if presented by a service they are connecting
to.

# Certificate Authorities for CDK

CDK can use a CA provided by any charm which [provides a tls-certificates
endpoint][provides-tls].  The two current recommendations are
[EasyRSA](#easyrsa) and [Vault](#vault).

## EasyRSA

By default, the CDK bundle includes the [EasyRSA charm][easyrsa-charm].  This
is a relatively simple charm which uses [OpenVPN's easy-rsa][easy-rsa] to
provide a CA and sign certificates.  This is fairly lightweight and works out
of the box without any additional configuration, but it cannot act as an
intermediary CA and does not support [HA][].

## Vault

For production systems, it is recommended to replace EasyRSA with the [Vault
charm][vault-charm].  This uses [HashiCorp's Vault][vault] to provide either a
root or intermediate CA.  It can also be deployed HA, as well provide a secure
secrets store which can be used to enable encryption-at-rest for CDK.  However,
it requires a database to store its data in, and (depending on configuration)
some manual steps will be required after deployment as well as after any reboot
to unseal Vault so that the secrets, such as certificates and signing keys, can
be accessed.

### Deploying CDK with Vault as a Root CA

You can replace EasyRSA with Vault by deploying with the following overlay:

```yaml
applications:
  easyrsa:
    # it's currently not possible to remove an application in an overlay
    num_units: 0
  vault:
    charm: cs:~openstack-charmers-next/vault
    num_units: 1
    options:
      auto-generate-root-ca-cert: true
  percona-cluster:
    charm: cs:percona-cluster
    num_units: 1
relations:
- - kubernetes-master:certificates
  - vault:certificates
- - etcd:certificates
  - vault:certificates
- - kubernetes-worker:certificates
  - vault:certificates
- - vault:shared-db
  - percona-cluster:shared-db                                                                                                                                                                                 
```

Save this to a file named `k8s-vault.yaml` and deploy with:

```
juju deploy cs:canonical-kubernetes --overlay ./k8s-vault.yaml
```

Once the deployment settles, you will notice that several applications are in a
`blocked` state in Juju, with Vault indicating that it needs to be initialized
and unsealed.  To unseal Vault, you can see [the guide][vault-guide-unseal] for
in-depth instructions (you may also need to [expose][] Vault), or you can use
the Vault client already on the Vault unit with the following steps:

```bash
juju ssh vault/0
export HISTCONTROL=ignorespace  # enable leading space to suppress command history
export VAULT_ADDR='http://localhost:8200'
vault operator init -key-shares=5 -key-threshold=3  # this will give you 5 keys and a root token
  vault operator unseal {key1}
  vault operator unseal {key2}
  vault operator unseal {key3}
  VAULT_TOKEN={root token} vault token create -ttl 10m  # this will give you a token to auth the charm
exit
juju run-action vault/0 authorize-charm token={charm token}
```

Note that it is **critical** that you save all 5 unseal keys as well as the
root token.  If the Vault unit is ever rebooted, you will have to repeat the
unseal steps (but not the init step) before the CA can become functional again.

### Using Vault as an Intermediary CA

If you don't wish for Vault to act as a self-signed root CA, you can remove the
`auto-generate-root-ca-cert: true` option from the overlay and follow [these
instructions][vault-guide-csr] to generate a [Certificate Signing Request
(CSR)][csr], have it signed by a trusted root CA, and upload it back to Vault.

### Using Vault in Auto-Unseal Mode

The Vault charm supports the ability to store and manage the unseal keys and
root token using Juju [leadership data][leadership].  Note that this means that
the unseal keys can be accessed at any time from the machine that Vault is
running on, significantly reducing the security of Vault, particularly with
respect to serving as a secure secrets store.  If you are comfortable with this
reduction in security and don't want to have to deal with the manual steps
involved in managing the unseal keys and root token, you can add the following
to the `options` section of `vault` in the overlay above:

```yaml
    totally-unsecure-auto-unlock: true
```

### Using Vault with HA

To enable HA for Vault, you will need to add [hacluster][], as well as a
relation between Vault and Etcd.  You may also need EasyRSA to provide a
certificate for Etcd before Vault can be brought up, although it may be
possible to first bring up Vault in non-HA mode and then transition to HA (this
needs checking).

More details can be found [in the guide][vault-guide-ha].


<!-- LINKS -->

[CDK]: http://jujucharms.com/canonical-kubernetes
[TLS]: https://www.networkworld.com/article/2303073/lan-wan/lan-wan-what-is-transport-layer-security-protocol.html
[PKI]: https://github.com/OpenVPN/easy-rsa/blob/master/doc/Intro-To-PKI.md
[chain of trust]: https://en.wikipedia.org/wiki/Chain_of_trust
[CA]: https://en.wikipedia.org/wiki/Certificate_authority
[Juju units]: https://docs.jujucharms.com/juju-concepts#unit-and-application
[Juju controller]: https://docs.jujucharms.com/controllers
[tls-certificates]: https://github.com/juju-solutions/interface-tls-certificates
[interface]: https://docs.jujucharms.com/juju-concepts#interface
[websockets]: https://en.wikipedia.org/wiki/WebSocket
[cloud-init]: https://cloud-init.io/
[relation]: https://docs.jujucharms.com/2.4/en/juju-concepts#relation
[vault-charm]: https://jujucharms.com/u/openstack-charmers-next/vault/
[vault]: https://www.vaultproject.io
[easyrsa-charm]: https://jujucharms.com/u/containers/easyrsa/
[easy-rsa]: https://github.com/OpenVPN/easy-rsa
[leadership]: https://docs.jujucharms.com/authors-charm-leadership
[install_ca_cert]: https://charm-helpers.readthedocs.io/en/latest/api/charmhelpers.core.host.html#charmhelpers.core.host.install_ca_cert
[Comodo]: https://en.wikipedia.org/wiki/Comodo_Group
[DigiCert]: https://en.wikipedia.org/wiki/DigiCert
[kubelet]: https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/
[server certificate]: https://en.wikipedia.org/wiki/Public_key_certificate#TLS/SSL_server_certificate
[client certificate]: https://en.wikipedia.org/wiki/Public_key_certificate#TLS/SSL_client_certificate
[CN]: https://knowledge.digicert.com/solution/SO7239.html
[SANs]: https://en.wikipedia.org/wiki/Subject_Alternative_Name
[network primitives]: https://docs.jujucharms.com/developer-network-primitives
[kubernetes-master]: https://jujucharms.com/u/containers/kubernetes-master/
[`extra_sans`]: https://jujucharms.com/u/containers/kubernetes-master/#charm-config-extra_sans
[provides-tls]: https://jujucharms.com/q/?provides=tls-certificates
[HA]: https://en.wikipedia.org/wiki/High_availability
[vault-guide-unseal]: https://docs.openstack.org/project-deploy-guide/charm-deployment-guide/latest/app-vault.html#initialize-and-unseal-vault
[vault-guide-ha]: https://docs.openstack.org/project-deploy-guide/charm-deployment-guide/latest/app-vault.html#enabling-ha
[vault-guide-csr]: https://docs.openstack.org/project-deploy-guide/charm-deployment-guide/latest/app-certificate-management.html
[csr]: https://en.wikipedia.org/wiki/Certificate_signing_request
[expose]: https://docs.jujucharms.com/charms-exposing
[hacluster]: https://jujucharms.com/hacluster
[vault-bug-ttl]: https://bugs.launchpad.net/vault-charm/+bug/1788945
