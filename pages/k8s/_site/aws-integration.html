<p><strong>Charmed Kubernetes</strong> will run seamlessly on AWS.  With the addition of the
<code class="highlighter-rouge">aws-integrator</code>, your cluster will also be able to directly use AWS native
features.</p>

<h2 id="aws-integrator">AWS integrator</h2>

<p>The <code class="highlighter-rouge">aws-integrator</code> charm simplifies working with <strong>Charmed Kubernetes</strong> on
AWS. Using the credentials provided to <strong>Juju</strong>, it acts as a proxy between
Charmed Kubernetes and the underlying cloud, granting permissions to
dynamically create, for example, EBS volumes.</p>

<h3 id="installing">Installing</h3>

<p>If you install <strong>Charmed Kubernetes</strong> <a href="/kubernetes/docs/install-manual">using the Juju bundle</a>, you can add the
aws-integrator at the same time by using the following overlay file (<a href="https://raw.githubusercontent.com/charmed-kubernetes/bundle/master/overlays/aws-overlay.yaml">download
it here</a>):</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">description</span><span class="pi">:</span> <span class="s">Charmed Kubernetes overlay to add native AWS support.</span>
<span class="na">applications</span><span class="pi">:</span>
  <span class="na">aws-integrator</span><span class="pi">:</span>
    <span class="na">annotations</span><span class="pi">:</span>
      <span class="na">gui-x</span><span class="pi">:</span> <span class="s2">"</span><span class="s">600"</span>
      <span class="na">gui-y</span><span class="pi">:</span> <span class="s2">"</span><span class="s">300"</span>
    <span class="na">charm</span><span class="pi">:</span> <span class="s">cs:~containers/aws-integrator</span>
    <span class="na">num_units</span><span class="pi">:</span> <span class="s">1</span>
    <span class="na">trust</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">relations</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="pi">[</span><span class="s1">'</span><span class="s">aws-integrator'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">kubernetes-master'</span><span class="pi">]</span>
  <span class="pi">-</span> <span class="pi">[</span><span class="s1">'</span><span class="s">aws-integrator'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">kubernetes-worker'</span><span class="pi">]</span>
</code></pre></div></div>

<p>To use this overlay with the <strong>Charmed Kubernetes</strong> bundle, it is specified during deploy like this:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>juju deploy charmed-kubernetes  <span class="nt">--overlay</span> ~/path/aws-overlay.yaml
</code></pre></div></div>

<p>Then run the command to share credentials with this charm:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>juju trust aws-integrator
</code></pre></div></div>

<p>… and remember to fetch the configuration file!</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>juju scp kubernetes-master/0:config ~/.kube/config
</code></pre></div></div>

<p>For more configuration options and details of the permissions which the integrator uses,
please see the <a href="https://jujucharms.com/u/containers/aws-integrator/">charm readme</a>.</p>

<h3 id="using-ebs-volumes">Using EBS volumes</h3>

<p>Many  pods you may wish to deploy will require storage. Although you can use
any type of storage supported by Kubernetes (see the
<a href="/kubernetes/docs/storage">storage documentation</a>), you also have the option to use the native
AWS storage, Elastic Block Store (EBS).</p>

<p>First we need to create a storage class which can be used by Kubernetes.
To start with, we will create one for the ‘General Purpose SSD’ type of EBS
storage:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create <span class="nt">-f</span> - <span class="o">&lt;&lt;</span><span class="no">EOY</span><span class="sh">
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ebs-gp2
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
</span><span class="no">EOY
</span></code></pre></div></div>

<p>You can confirm this has been added by running:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get sc
</code></pre></div></div>

<p>which should return:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME      PROVISIONER             AGE
ebs-gp2   kubernetes.io/aws-ebs   39s
</code></pre></div></div>

<p>You can create additional storage classes for the other types of EBS storage if
needed, simply give them a different name and replace the ‘type: gp2’ with a
different type (See the <a href="https://aws.amazon.com/ebs/features/">AWS website</a> for more information on the
available types).</p>

<p>To actually create storage using this new class, you can make a Persistent Volume Claim:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create <span class="nt">-f</span> - <span class="o">&lt;&lt;</span><span class="no">EOY</span><span class="sh">
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: testclaim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 100Mi
  storageClassName: ebs-gp2
</span><span class="no">EOY
</span></code></pre></div></div>

<p>This should finish with a confirmation. You can check the current PVCs with:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pvc
</code></pre></div></div>

<p>…which should return something similar to:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
testclaim   Bound    pvc-54a94dfa-3128-11e9-9c54-028fdae42a8c   1Gi        RWO            ebs-gp2        9s
</code></pre></div></div>

<p>This PVC can then be used by pods operating in the cluster. As an example, the following
deploys a <code class="highlighter-rouge">busybox</code> pod:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create <span class="nt">-f</span> - <span class="o">&lt;&lt;</span><span class="no">EOY</span><span class="sh">
apiVersion: v1
kind: Pod
metadata:
  name: busybox
  namespace: default
spec:
  containers:
    - image: busybox
      command:
        - sleep
        - "3600"
      imagePullPolicy: IfNotPresent
      name: busybox
      volumeMounts:
        - mountPath: "/pv"
          name: testvolume
  restartPolicy: Always
  volumes:
    - name: testvolume
      persistentVolumeClaim:
        claimName: testclaim
</span><span class="no">EOY
</span></code></pre></div></div>

<div class="p-notification--caution">
  <p class="p-notification__response">
    <span class="p-notification__status">Note:</span>
If you create EBS volumes and subsequently tear down the cluster, check
with the AWS console to make sure all the associated resources have also been released.
  </p>
</div>

<h3 id="using-elb-loadbalancers">Using ELB Loadbalancers</h3>

<p>With the aws-integrator charm in place, actions which invoke a loadbalancer in
Kubernetes  will automatically generate an AWS Elastic Load Balancer.  This can
be demonstrated with a simple application. Here we will create a simple
application running in five pods:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl run hello-world <span class="nt">--replicas</span><span class="o">=</span>5 <span class="nt">--labels</span><span class="o">=</span><span class="s2">"run=load-balancer-example"</span> <span class="nt">--image</span><span class="o">=</span>gcr.io/google-samples/node-hello:1.0  <span class="nt">--port</span><span class="o">=</span>8080
</code></pre></div></div>

<p>You can verify that the application and replicas have been created with:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl get deployments hello-world
</code></pre></div></div>

<p>Which should return output similar to:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> NAME              READY   UP-TO-DATE   AVAILABLE   AGE
 hello-world      5/5               5                            5             2m38s
</code></pre></div></div>

<p>To create a LoadBalancer, the application should now be exposed as a service:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> kubectl expose deployment hello-world <span class="nt">--type</span><span class="o">=</span>LoadBalancer <span class="nt">--name</span><span class="o">=</span>hello
</code></pre></div></div>

<p>To check that the service is running correctly:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl describe service hello
</code></pre></div></div>

<p>…which should return output similar to:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Name</span><span class="pi">:</span>                     <span class="s">hello</span>
<span class="na">Namespace</span><span class="pi">:</span>                <span class="s">default</span>
<span class="na">Labels</span><span class="pi">:</span>                   <span class="s">run=load-balancer-example</span>
<span class="na">Annotations</span><span class="pi">:</span>              <span class="s">&lt;none&gt;</span>
<span class="na">Selector</span><span class="pi">:</span>                 <span class="s">run=load-balancer-example</span>
<span class="na">Type</span><span class="pi">:</span>                     <span class="s">LoadBalancer</span>
<span class="na">IP</span><span class="pi">:</span>                       <span class="s">10.152.183.134</span>
<span class="na">LoadBalancer Ingress</span><span class="pi">:</span>     <span class="s">ad5fc7750350611e99768068a686bb67-239702253.eu-west-1.elb.amazonaws.com</span>
<span class="na">Port</span><span class="pi">:</span>                     <span class="s">&lt;unset&gt;  8080/TCP</span>
<span class="na">TargetPort</span><span class="pi">:</span>               <span class="s">8080/TCP</span>
<span class="na">NodePort</span><span class="pi">:</span>                 <span class="s">&lt;unset&gt;  31203/TCP</span>
<span class="na">Endpoints</span><span class="pi">:</span>                <span class="s">10.1.13.4:8080,10.1.13.5:8080,10.1.35.8:8080 + 2 more...</span>
<span class="na">Session Affinity</span><span class="pi">:</span>         <span class="s">None</span>
<span class="na">External Traffic Policy</span><span class="pi">:</span>  <span class="s">Cluster</span>
<span class="na">Events</span><span class="pi">:</span>                   <span class="s">&lt;none&gt;</span>
</code></pre></div></div>

<p>You can see that the LoadBalancer Ingress is now associated with an ELB address in front
of the five endpoints of the  example deployment. Leaving a while for DNS propagation, you
can test the ingress address:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl  http://ad5fc7750350611e99768068a686bb67-239702253.eu-west-1.elb.amazonaws.com:8080
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello Kubernetes!
</code></pre></div></div>

<div class="p-notification--caution">
  <p class="p-notification__response">
    <span class="p-notification__status">Note:</span>
If you create ELBs and subsequently tear down the cluster, check with the AWS console
to make sure all the associated resources have also been released.
  </p>
</div>

<h3 id="upgrading-the-integrator-charm">Upgrading the integrator-charm</h3>

<p>The aws-integrator is not specifically tied to the version of Charmed Kubernetes installed and may
generally be upgraded at any time with the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>juju upgrade-charm aws-integrator
</code></pre></div></div>

<h3 id="troubleshooting">Troubleshooting</h3>

<p>If you have any specific problems with the aws-integrator, you can report bugs on
<a href="https://bugs.launchpad.net/charmed-kubernetes">Launchpad</a>.</p>

<p>The aws-integrator charm makes use of IAM accounts in AWS to perform actions, so
useful information can be obtained from <a href="https://console.aws.amazon.com/cloudtrail/">Amazon’s CloudTrail</a>,
which logs such activity.</p>

<p>For logs of what the charm itself believes the world to look like, you can use
Juju to replay the log history for that specific unit:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>juju debug-log <span class="nt">--replay</span> <span class="nt">--include</span> aws-integrator/0
</code></pre></div></div>

<h2 id="see-also">See also:</h2>

<p>If you are an AWS user, you may also be interested in how to
<a href="/kubernetes/docs/aws-iam-auth">use AWS IAM for authorisation and authentication</a>.</p>

<!-- LINKS -->

<!-- FEEDBACK -->
<div class="p-notification--information">
  <p class="p-notification__response">
    We appreciate your feedback on the documentation. You can 
    <a href="https://github.com/charmed-kubernetes/kubernetes-docs/edit/master/pages/k8s/aws-integration.md" class="p-notification__action">edit this page</a> 
    or 
    <a href="https://github.com/charmed-kubernetes/kubernetes-docs/issues/new" class="p-notification__action">file a bug here</a>.
  </p>
</div>
